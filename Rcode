## Predicting leaf internal to ambient CO2 concentration (ci/ca or chi) using the least-cost hypothesis 
## and gross primary production (GPP) using the coordination hypothesis (Prentice et al., 2014; Wang et al. 2017)

## by Alienor Lavergne
## updated on 29 June 2019

##===================================
## 1. parameterization
##===================================

beta <- 146 # the ratio of cost factor b to a at reference temperature, as in Smith et al. (2019)
cstar <- 0.41 # the cost factor of maintaining Jmax, as in Wang et al. (2017)

kTo <- 25   # base temperature, C (Berberan-Santos at el. 1997)
kPo <- 101325   # standard atmosphere, Pa (Allen, 1973)


##===================================
## 2. define functions
##===================================

  # calculate air pressure in Pa
  calc_patm <- function( elv ){
    #-----------------------------------------------------------------------
    # Input:    - elevation, m (elv)
    # Output:   - float, atmospheric pressure at elevation 'elv', Pa (patm)
    # Features: Returns the atmospheric pressure as a function of elevation
    #           and standard atmosphere (1013.25 hPa)
    # Depends:  - connect_sql
    #           - flux_to_grid
    #           - get_data_point
    #           - get_msvidx
    # Ref:      Allen et al. (1998)
    #-----------------------------------------------------------------------
    
    # Define constants:
    kPo <- 101325   # standard atmosphere, Pa (Allen, 1973)
    kTo <- 298.15   # base temperature, K (Berberan-Santos at el. 1997)
    #kTo <- 288.15   # base temperature, K (Wang et al., 2017, New Phyto.)
    kL <- 0.0065    # temperature lapse rate, K/m (Allen, 1973)
    kG <- 9.80665   # gravitational acceleration, m/s^2 (Allen, 1973)
    kR <- 8.3143    # universal gas constant, J/mol/K (Allen, 1973)
    kMa <- 0.028963 # molecular weight of dry air, kg/mol (Tsilingiris, 2008)
    
    
    # Convert elevation to pressure, Pa:
    patm <- kPo*(1.0 - kL*elv/kTo)**(kG*kMa/(kR*kL))
    
    return (patm)
  }
 
   
  # calculate K (MM coefficient of Rubisco) in Pa
  calc_k <- function(tc, patm) {
    #-----------------------------------------------------------------------
    # Input:    - float, air temperature, deg C (temp)
    #           - float, atmospheric pressure, Pa (patm)
    # Output:   float, Pa (mmk)
    # Features: Returns the temperature & pressure dependent Michaelis-Menten
    #           coefficient, K (Pa).
    # Ref:      Bernacchi et al. (2001), Improved temperature response 
    #           functions for models of Rubisco-limited photosynthesis, 
    #           Plant, Cell and Environment, 24, 253--259.
    #-----------------------------------------------------------------------
    
    # Define constants
    kc25 <- 39.97      # Pa, assuming 25 deg C & 98.716 kPa
    ko25 <- 2.748e4    # Pa, assuming 25 deg C & 98.716 kPa
    dhac <- 79430      # J/mol
    dhao <- 36380      # J/mol
    kR   <- 8.3145     # J/mol/K
    kco  <- 2.09476e5  # ppm, US Standard Atmosphere
    
    vc <- kc25*exp(dhac*(tc - 25.0)/(298.15*kR*(tc + 273.15)))
    vo <- ko25*exp(dhao*(tc - 25.0)/(298.15*kR*(tc + 273.15)))
    k  <- vc*(1 + kco*(1e-6)*patm/vo)
    
    return(k)
    
  }
  
  
  ## calculate density of water at Patm (kg/m3)
  density_h2o <- function( tc, patm ){
    #-----------------------------------------------------------------------
    # Input:    - float, air temperature (tc), degrees C
    #           - float, atmospheric pressure (p), Pa
    # Output:   float, density of water, kg/m^3
    # Features: Calculates density of water at a given temperature and
    #           pressure using the Tumlirz Equation
    # Ref:      F.H. Fisher and O.E Dial, Jr. (1975) Equation of state of
    #           pure water and sea water, Tech. Rept., Marine Physical
    #           Laboratory, San Diego, CA.
    #-----------------------------------------------------------------------
    
    # Calculate lambda, (bar cm^3)/g:
    my_lambda <- 1788.316 +
      21.55053*tc +
      -0.4695911*tc*tc +
      (3.096363e-3)*tc*tc*tc +
      -(7.341182e-6)*tc*tc*tc*tc
    
    # Calculate po, bar
    po <- 5918.499 +
      58.05267*tc +
      -1.1253317*tc*tc +
      (6.6123869e-3)*tc*tc*tc +
      -(1.4661625e-5)*tc*tc*tc*tc
    
    # Calculate vinf, cm^3/g
    vinf <- 0.6980547 +
      -(7.435626e-4)*tc +
      (3.704258e-5)*tc*tc +
      -(6.315724e-7)*tc*tc*tc +
      (9.829576e-9)*tc*tc*tc*tc +
      -(1.197269e-10)*tc*tc*tc*tc*tc +
      (1.005461e-12)*tc*tc*tc*tc*tc*tc +
      -(5.437898e-15)*tc*tc*tc*tc*tc*tc*tc +
      (1.69946e-17)*tc*tc*tc*tc*tc*tc*tc*tc +
      -(2.295063e-20)*tc*tc*tc*tc*tc*tc*tc*tc*tc
    
    # Convert pressure to bars (1 bar <- 100000 Pa)
    pbar <- (1e-5)*patm
    
    # Calculate the specific volume (cm^3 g^-1):
    v <- vinf + my_lambda/(po + pbar)
    
    # Convert to density (g cm^-3) -> 1000 g/kg; 1000000 cm^3/m^3 -> kg/m^3:
    rho <- (1e3/v)
    
    return(rho)
  }
  
  
  # calculate viscosity of water (mu) in Pa/s
  viscosity_h2o <- function( tc, patm ) {
    #-----------------------------------------------------------------------
    # Input:    - float, ambient temperature (tc), degrees C
    #           - float, ambient pressure (p), Pa
    # Return:   float, viscosity of water (mu), Pa s
    # Features: Calculates viscosity of water at a given temperature and 
    #           pressure.
    # Depends:  density_h2o
    # Ref:      Huber, M. L., R. A. Perkins, A. Laesecke, D. G. Friend, J. V. 
    #           Sengers, M. J. Assael, ..., K. Miyagawa (2009) New 
    #           international formulation for the viscosity of H2O, J. Phys. 
    #           Chem. Ref. Data, Vol. 38(2), pp. 101-125.
    #-----------------------------------------------------------------------
    
    # Define reference temperature, density, and pressure values:
    tk_ast  <- 647.096    # Kelvin
    rho_ast <- 322.0      # kg/m^3
    mu_ast  <- 1e-6       # Pa s
    
    # Get the density of water, kg/m^3
    rho <- density_h2o(tc, patm)
    
    # Calculate dimensionless parameters:
    tbar <- (tc + 273.15)/tk_ast
    tbarx <- tbar^(0.5)
    tbar2 <- tbar^2
    tbar3 <- tbar^3
    rbar <- rho/rho_ast
    
    # Calculate mu0 (Eq. 11 & Table 2, Huber et al., 2009):
    mu0 <- 1.67752 + 2.20462/tbar + 0.6366564/tbar2 - 0.241605/tbar3
    mu0 <- 1e2*tbarx/mu0
    
    # Create Table 3, Huber et al. (2009):
    h_array <- array(0.0, dim=c(7,6))
    h_array[1,] <- c(0.520094, 0.0850895, -1.08374, -0.289555, 0.0, 0.0)  # hj0
    h_array[2,] <- c(0.222531, 0.999115, 1.88797, 1.26613, 0.0, 0.120573) # hj1
    h_array[3,] <- c(-0.281378, -0.906851, -0.772479, -0.489837, -0.257040, 0.0) # hj2
    h_array[4,] <- c(0.161913,  0.257399, 0.0, 0.0, 0.0, 0.0) # hj3
    h_array[5,] <- c(-0.0325372, 0.0, 0.0, 0.0698452, 0.0, 0.0) # hj4
    h_array[6,] <- c(0.0, 0.0, 0.0, 0.0, 0.00872102, 0.0) # hj5
    h_array[7,] <- c(0.0, 0.0, 0.0, -0.00435673, 0.0, -0.000593264) # hj6
    
    # Calculate mu1 (Eq. 12 & Table 3, Huber et al., 2009):
    mu1 <- 0.0
    ctbar <- (1.0/tbar) - 1.0
    # print(paste("ctbar",ctbar))
    # for i in xrange(6):
    for (i in 1:6){
      coef1 <- ctbar^(i-1)
      # print(paste("i, coef1", i, coef1))
      coef2 <- 0.0
      for (j in 1:7){
        coef2 <- coef2 + h_array[j,i] * (rbar - 1.0)^(j-1)
      }
      mu1 <- mu1 + coef1 * coef2    
    }
    mu1 <- exp( rbar * mu1 )
    # print(paste("mu1",mu1))
    
    # Calculate mu_bar (Eq. 2, Huber et al., 2009)
    #   assumes mu2 = 1
    mu_bar <- mu0 * mu1
    
    # Calculate mu (Eq. 1, Huber et al., 2009)
    mu <- mu_bar * mu_ast    # Pa s
    
    return( mu )
  }
  
  
  # calculate Gstar (CO2 compensation point) in Pa
  CO2.compens.point <- function( tc ) {
    #-----------------------------------------------------------------------
    # Input:    float, air temperature, degrees C (tc)
    #         
    # Output:   float, gamma-star, Pa (Gstar)
    # Features: Returns the temperature-dependent photorespiratory 
    #           compensation point, Gamma star (Pascals), based on constants 
    #           derived from Bernacchi et al. (2001) study.
    # Ref:      Bernacchi et al. (2001), Improved temperature response 
    #           functions for models of Rubisco-limited photosynthesis, 
    #           Plant, Cell and Environment, 24, 253--259.
    #-----------------------------------------------------------------------
    
    # Define constants
    gs25 <- 4.220    # Pa, assuming 25 deg C & 98.716 kPa)
    dha  <- 37830    # J/mol
    kR   <- 8.3145   # J/mol/K
    
    Gstar <- gs25 * exp( dha * ( tc - 25.0 ) / ( 298.15 * kR * ( tc + 273.15 ) ) )
    
    return( Gstar )
    
  }
  
  
  # convert CO2 from ppm to Pa
  co2_to_ca <- function( ca, patm ){
    #-----------------------------------------------------------------------
    # Input:    - float, annual atm. CO2, ppm (co2)
    #           - float, monthly atm. pressure, Pa (patm)
    # Output:   - ca in units of Pa
    # Features: Converts ca (ambient CO2) from ppm to Pa.
    #-----------------------------------------------------------------------
    co2   <- ( 1.e-6 ) * ca * patm         # Pa, atms. CO2
    return( co2 )
  }



##============================================
## 3. calculate ci/ca with least-cost hypothesis for different versions
##============================================

  # simple version: equation (8) in Wang et al. (2017) 
chi_simple <- function (tc, elv, vpd) {
  #-----------------------------------------------------------------------
  # Input:    float, air temperature, degrees C (tc)
  #           float, VPD (kPa)
  #           float, elevation (m)
  # Output:   float, ci/ca
  # Ref:      Wang et al. (2017), Nature Plants 
  #-----------------------------------------------------------------------
  
  patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
  kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
  
  ns      <- viscosity_h2o( tc, patm )  # Pa s 
  ns25    <- viscosity_h2o( kTo, kPo )  # Pa s 
  ns_star <- ns / ns25  # (unitless)
  
  xi  <- sqrt( (beta * kmm ) / ( 1.6 * ns_star ) )
  
  vpd_Pa <- vpd*1.e3  ## conversion kPa to Pa
  
  chi <- xi / (xi + sqrt(vpd_Pa))
  return(chi)
}


  # complex version: equation (9) in Wang et al. (2017) 
chi_complex <- function (tc, elv, vpd,ca) {
  #-----------------------------------------------------------------------
  # Input:    float, air temperature, degrees C (tc)
  #           float, VPD (kPa)
  #           float, elevation (m)
  #           float, CO2 (ppm)
  #           float, CO2 compensation (m)
  # Output:   float, ci/ca
  # Ref:      Wang et al. (2017), Nature Plants 
  #-----------------------------------------------------------------------
  
  patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
  kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa

  ## Conversion atmospheric [CO2] from ppm to Pa
  co2<-co2_to_ca(ca, patm)
  
  Gstar<-CO2.compens.point( tc ) # Pa
    
  ns      <- viscosity_h2o( tc, patm )  # Pa s 
  ns25    <- viscosity_h2o( kTo, kPo )  # Pa s 
  ns_star <- ns / ns25  # (unitless)

  xi  <- sqrt( (beta * (kmm + Gstar)) / ( 1.6 * ns_star ) )
  
  vpd_Pa <- vpd*1.e3  ## conversion kPa to Pa
  chi <- Gstar/co2 + (1-Gstar/co2)*xi / (xi + sqrt(vpd_Pa))
  return(chi)
}

# version considering mesophyll conductance: equation (33) in Wang et al. (2017) 
chc_simple <- function (tc, elv, vpd,teta) {
  #-----------------------------------------------------------------------
  # Input:    float, air temperature, degrees C (tc)
  #           float, VPD (kPa)
  #           float, elevation (m)
  #           float, teta (unitless)
  # Output:   float, cc/ca
  # Ref:      Wang et al. (2017), Nature Plants 
  #-----------------------------------------------------------------------
  
  patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
  kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
  
  Gstar<-CO2.compens.point( tc ) # Pa
  
  ns      <- viscosity_h2o( tc, patm )  # Pa s
  ns25    <- viscosity_h2o( kTo, kPo )  # Pa s
  ns_star <- ns / ns25  # (unitless)
  
  xc  <- sqrt( (beta * kmm ) / ( 1.6 * ns_star)/(1+1/teta) )   ## teta = gm/gs = 1.4 Wang et al. 2017
  
  vpd_Pa <- vpd*1.e3  ## conversion kPa to Pa
  
  chc <- xc / (xc + sqrt(vpd_Pa))
  return(chc)
}


  # version considering mesophyll conductance: equation (34) in Wang et al. (2017) 
chc_complex <- function (tc, elv, vpd,ca,teta) {
  #-----------------------------------------------------------------------
  # Input:    float, air temperature, degrees C (tc)
  #           float, VPD (kPa)
  #           float, elevation (m)
  #           float, CO2 (ppm)
  #           float, teta (unitless)
  # Output:   float, cc/ca
  # Ref:      Wang et al. (2017), Nature Plants 
  #-----------------------------------------------------------------------
  
  patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
  kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
  
  ## Conversion atmospheric [CO2] from ppm to Pa
  co2<-co2_to_ca(ca, patm)
  
  Gstar<-CO2.compens.point( tc ) # Pa
  
  ns      <- viscosity_h2o( tc, patm )  # Pa s
  ns25    <- viscosity_h2o( kTo, kPo )  # Pa s
  ns_star <- ns / ns25  # (unitless)

  xc  <- sqrt( (beta * (kmm + Gstar)) / ( 1.6 * ns_star*(1+1/teta) ) )  ## teta = gm/gs = 1.4 Wang et al. 2017
  
  vpd_Pa <- vpd*1.e3  ## conversion kPa to Pa
  
  chc <- Gstar/co2 + (1-Gstar/co2)*xc / (xc + sqrt(vpd_Pa))
  return(chc)
}


# ## ki 
# xi_simple <- function (tc,elv) {
#   patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
#   kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
#   
#   ns      <- viscosity_h2o( tc, patm )  # Pa s 
#   ns25    <- viscosity_h2o( kTo, kPo )  # Pa s 
#   ns_star <- ns / ns25  # (unitless)
#   
#   xi  <- sqrt( (beta * kmm ) / ( 1.6 * ns_star ) )
#   
#   return(xi)
# }
# 
# 
# xi_complex <- function (tc,elv) {
#   patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
#   kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
#   
#   Gstar<-CO2.compens.point( tc ) # Pa
#   
#   ns      <- viscosity_h2o( tc, patm )  # Pa s 
#   ns25    <- viscosity_h2o( kTo, kPo )  # Pa s 
#   ns_star <- ns / ns25  # (unitless)
#   
#   xi  <- sqrt( (beta * (kmm + Gstar)) / ( 1.6 * ns_star ) )
#   
#   return(xi)
# }
# 
# 
# xc_complex <- function (tc,elv,teta) {
#   
#   patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
#   kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
#   
#   Gstar<-CO2.compens.point( tc ) # Pa
#   
#   ns      <- viscosity_h2o( tc, patm )  # Pa s
#   ns25    <- viscosity_h2o( kTo, kPo )  # Pa s
#   ns_star <- ns / ns25  # (unitless)
#   
#   xc  <- sqrt( (beta * (kmm + Gstar)) / ( 1.6 * ns_star*(1+1/teta) ) )  ## teta = gm/gs = 1.4 Wang et al. 2017
#   
#   return(xc)
# }




##============================================
## 4. Calculating GPP with coordination hypothesis
##============================================

calc_GPP <- function (tc, elv, ca, vpd, PPFD,fAPAR) {
  #-----------------------------------------------------------------------
  # Input:    float, air temperature, degrees C (tc)
  #           float, VPD (kPa)
  #           float, elevation (m)
  #           float, CO2 (ppm)
  #           float, PPFD (mol m-2 time-1)
  #           float, fAPAR (unitless)
  # Output:   float, GPP (gC m-2 time-1)
  # Ref:      Wang et al. (2017), Nature Plants 
  #-----------------------------------------------------------------------
  
  maxQE <- 0.044 + 0.002625*tc - 0.425e-4*tc^2 ## instrinsic quantum yield for C3 plants based on Bernacchi et al. 2003
  maxQE<- maxQE*12.0107 # unit: g C/ mol photon
  
  patm <- calc_patm( elv )  ### unite of elv is meter Patm in Pa
  kmm  <- calc_k( tc, patm ) #### tc degree c, patm : Pa, kmm : Pa
  
  Gstar <- CO2.compens.point(tc)
  vpd_Pa <- vpd*1.e3  ## conversion kPa to Pa
  
  ns      <- viscosity_h2o( tc, patm )  # Pa s
  ns25    <- viscosity_h2o( kTo, kPo )  # Pa s
  ns_star <- ns / ns25  # (unitless)
  
  
  ## Conversion atmospheric [CO2] from ppm to Pa
  co2<-co2_to_ca(ca, patm)
  
  m <- (co2 - Gstar)/(co2 + 2*Gstar + 3*Gstar*sqrt((1.6*ns_star*vpd_Pa)/(beta)*1/(kmm + Gstar)))
  
  M <- m*sqrt(1-(cstar/m)^(2/3))
  M[is.na(M)] <- 0
  
  LUE <- M*maxQE  
  Iabs <- fAPAR*PPFD
  GPP <- LUE*Iabs
  return(GPP)
}




